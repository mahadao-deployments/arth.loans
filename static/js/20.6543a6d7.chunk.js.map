{"version":3,"sources":["../../src/index.ts"],"names":["AbstractConnector","supportedChainIds","emitUpdate","update","emit","ConnectorEvent","Update","emitError","error","Error","emitDeactivate","Deactivate","EventEmitter","URI_AVAILABLE","UserRejectedRequestError","name","constructor","message","getSupportedChains","rpc","Object","keys","map","k","Number","undefined","WalletConnectConnector","config","handleChainChanged","bind","handleAccountsChanged","handleDisconnect","chainId","this","accounts","account","walletConnectProvider","stop","removeListener","activate","enable","then","on","provider","wc","connected","createSession","length","uri","m","WalletConnectProvider","e","getProvider","getChainId","send","getAccount","deactivate","close"],"mappings":"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","file":"static/js/20.6543a6d7.chunk.js","sourcesContent":["import { ConnectorUpdate } from '@web3-react/types'\nimport { AbstractConnector } from '@web3-react/abstract-connector'\nimport { IWalletConnectProviderOptions } from '@walletconnect/types'\n\nexport const URI_AVAILABLE = 'URI_AVAILABLE'\n\nexport interface WalletConnectConnectorArguments extends IWalletConnectProviderOptions {\n  supportedChainIds?: number[]\n}\n\nexport class UserRejectedRequestError extends Error {\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    this.message = 'The user rejected the request.'\n  }\n}\n\nfunction getSupportedChains({ supportedChainIds, rpc }: WalletConnectConnectorArguments): number[] | undefined {\n  if (supportedChainIds) {\n    return supportedChainIds\n  }\n\n  return rpc ? Object.keys(rpc).map(k => Number(k)) : undefined\n}\n\nexport class WalletConnectConnector extends AbstractConnector {\n  private readonly config: WalletConnectConnectorArguments\n\n  public walletConnectProvider?: any\n\n  constructor(config: WalletConnectConnectorArguments) {\n    super({ supportedChainIds: getSupportedChains(config) })\n\n    this.config = config\n\n    this.handleChainChanged = this.handleChainChanged.bind(this)\n    this.handleAccountsChanged = this.handleAccountsChanged.bind(this)\n    this.handleDisconnect = this.handleDisconnect.bind(this)\n  }\n\n  private handleChainChanged(chainId: number | string): void {\n    if (__DEV__) {\n      console.log(\"Handling 'chainChanged' event with payload\", chainId)\n    }\n    this.emitUpdate({ chainId })\n  }\n\n  private handleAccountsChanged(accounts: string[]): void {\n    if (__DEV__) {\n      console.log(\"Handling 'accountsChanged' event with payload\", accounts)\n    }\n    this.emitUpdate({ account: accounts[0] })\n  }\n\n  private handleDisconnect(): void {\n    if (__DEV__) {\n      console.log(\"Handling 'disconnect' event\")\n    }\n    this.emitDeactivate()\n    // we have to do this because of a @walletconnect/web3-provider bug\n    if (this.walletConnectProvider) {\n      this.walletConnectProvider.stop()\n      this.walletConnectProvider.removeListener('chainChanged', this.handleChainChanged)\n      this.walletConnectProvider.removeListener('accountsChanged', this.handleAccountsChanged)\n      this.walletConnectProvider = undefined\n    }\n\n    this.emitDeactivate()\n  }\n\n  public async activate(): Promise<ConnectorUpdate> {\n    if (!this.walletConnectProvider) {\n      const WalletConnectProvider = await import('@walletconnect/web3-provider').then(m => m?.default ?? m)\n      this.walletConnectProvider = new WalletConnectProvider(this.config)\n    }\n\n    // ensure that the uri is going to be available, and emit an event if there's a new uri\n    if (!this.walletConnectProvider.wc.connected) {\n      await this.walletConnectProvider.wc.createSession({\n        chainId: this.supportedChainIds && this.supportedChainIds.length > 0 ? this.supportedChainIds[0] : 1\n      })\n      this.emit(URI_AVAILABLE, this.walletConnectProvider.wc.uri)\n    }\n\n    const account = await this.walletConnectProvider\n      .enable()\n      .then((accounts: string[]): string => accounts[0])\n      .catch((error: Error): void => {\n        // TODO ideally this would be a better check\n        if (error.message === 'User closed modal') {\n          throw new UserRejectedRequestError()\n        }\n\n        throw error\n      })\n\n    this.walletConnectProvider.on('disconnect', this.handleDisconnect)\n    this.walletConnectProvider.on('chainChanged', this.handleChainChanged)\n    this.walletConnectProvider.on('accountsChanged', this.handleAccountsChanged)\n\n    return { provider: this.walletConnectProvider, account }\n  }\n\n  public async getProvider(): Promise<any> {\n    return this.walletConnectProvider\n  }\n\n  public async getChainId(): Promise<number | string> {\n    return this.walletConnectProvider.send('eth_chainId')\n  }\n\n  public async getAccount(): Promise<null | string> {\n    return this.walletConnectProvider.send('eth_accounts').then((accounts: string[]): string => accounts[0])\n  }\n\n  public deactivate() {\n    if (this.walletConnectProvider) {\n      this.walletConnectProvider.stop()\n      this.walletConnectProvider.removeListener('disconnect', this.handleDisconnect)\n      this.walletConnectProvider.removeListener('chainChanged', this.handleChainChanged)\n      this.walletConnectProvider.removeListener('accountsChanged', this.handleAccountsChanged)\n    }\n  }\n\n  public async close() {\n    await this.walletConnectProvider?.close()\n  }\n}\n"],"sourceRoot":""}